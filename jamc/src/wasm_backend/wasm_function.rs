use hashbrown::{Equivalent, HashMap};
use std::borrow::Cow;
use std::hash::{Hash, Hasher};

use wasm_encoder::{
    ConstExpr, Elements, EntityType, ExportKind, Instruction, RefType, TableType, ValType,
};

use crate::{
    frontend::{
        ast::{ProcDef, Type},
        sema::Ty,
    },
    wasm_backend::{
        function_ctx::FunctionCtx,
        wasm_codegen::{WasmModule, WasmTypeId},
        wasm_debug::get_var_dbg_name,
    },
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct GenericInstTyKey {
    pub(crate) name: String,
    pub(crate) tys: Vec<Ty>,
}

#[derive(Debug, PartialEq, Eq)]
pub(crate) struct GenericInstTyKeyRef<'a> {
    pub(crate) name: &'a str,
    pub(crate) tys: &'a [Ty],
}

impl<'a> Equivalent<GenericInstTyKey> for GenericInstTyKeyRef<'a> {
    fn equivalent(&self, key: &GenericInstTyKey) -> bool {
        *self.name == key.name && *self.tys == key.tys
    }
}

impl<'a> Hash for GenericInstTyKeyRef<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
        self.tys.hash(state);
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum FunctionVariable {
    /// Contains the id of the local that holds the pointer
    PtrLocal(u32, bool),
    /// Local itself has this value
    Local(u32, bool),
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub(crate) struct SemaParam {
    ty: Ty,
    name: String,
    mutable: bool,
}

impl<'a> WasmModule<'a> {
    pub(crate) fn init_function_table(&mut self) {
        let len = self.table_entries_to_write.len();
        self.table_section.table(TableType {
            element_type: RefType::FUNCREF,
            minimum: len as u64,
            maximum: Some(len as u64),
            table64: false,
            shared: false,
        });
    }

    pub(crate) fn get_or_define_function(
        &mut self,
        function_key: &GenericInstTyKeyRef,
    ) -> WasmTypeId {
        if let Some(val) = self.function_to_id_map.get(function_key) {
            return *val;
        }

        // Else, create and map the function

        // Externals should be 'forward declared', so just check for user def'd functions
        let Some(proc_def) = self.internal_functions.get(function_key.name) else {
            panic!("Function '{}' is not defined", function_key.name);
        };

        // Create a generic context before defining the function
        let mut ctx = HashMap::new();
        for (idx, generic) in proc_def.generics.iter().enumerate() {
            let ty_from_key = self.full_resolve_generic(&function_key.tys[idx]);

            // Def's generics
            let crate::frontend::ast::Type::Generic {
                generic_name,
                index_in_decl: _,
            } = generic.clone()
            else {
                panic!()
            };
            ctx.insert(generic_name.text, ty_from_key);
        }

        // Push generic context
        self.generic_context.push(ctx);

        // declare the function. ensure we insert into function_to_id_map here to avoid inf recursion!
        let func_id = self.declare_function(function_key.name);
        // define the function

        // return the id generated by declare
        self.define_function(function_key.name);
        self.generic_context.pop();

        func_id
    }

    pub(crate) fn declare_external_function(&mut self, function_name: &str) -> WasmTypeId {
        let func_def = self.external_functions[function_name];

        // Check if it returns a struct - if so, use sret
        let (param_tys, ret_tys, _sret) = self.get_wasm_function_sig(
            &func_def.params.iter().map(|p| &p.ty).collect(),
            &func_def.ret_type,
        );
        let type_id = self.get_or_create_function_type(&param_tys, &ret_tys);

        let func_index = self.import_section.len() + self.function_section.len();

        // Add table entry to write later
        self.table_entries_to_write.push(TableEntry {
            table_index: 0,
            func_index: func_index,
            type_index: type_id,
        });

        self.import_section
            .import("env", &func_def.name.text, EntityType::Function(type_id));

        self.dbg_name_bld.add_func(func_index, function_name);

        let func_key = GenericInstTyKey {
            name: function_name.to_string(),
            tys: vec![],
        };

        // And any other mappings I'll need
        self.function_to_id_map.insert(func_key.clone(), func_index);

        return func_index;
    }

    pub(crate) fn declare_function(&mut self, function_name: &str) -> WasmTypeId {
        let func_def = &self.internal_functions[function_name];

        let generic_tys = if self.generic_context.has_context() {
            func_def
                .generics
                .iter()
                .map(|g| {
                    let Type::Generic {
                        generic_name,
                        index_in_decl: _,
                    } = g
                    else {
                        panic!()
                    };
                    self.generic_context.get_mapping(&generic_name.text).clone()
                })
                .collect()
        } else {
            vec![]
        };

        // Check if it returns a struct - if so, use sret
        let (param_tys, ret_tys, _uses_sret) = self.get_function_params(func_def);
        let type_id = self.get_or_create_function_type(&param_tys, &ret_tys);

        // Insert sret if needed, add params and return ty
        let func_index = self.import_section.len() + self.function_section.len();
        self.function_section.function(type_id);
        // Add table entry to write later
        self.table_entries_to_write.push(TableEntry {
            table_index: 0,
            func_index: func_index,
            type_index: type_id,
        });

        if generic_tys.is_empty() {
            self.export_section
                .export(function_name, ExportKind::Func, func_index);
        }

        // could use the generic mangled name
        let mangled = self.mangle_generic(function_name, &generic_tys);
        self.dbg_name_bld.add_func(func_index, &mangled);

        let func_key = GenericInstTyKey {
            name: function_name.to_string(),
            tys: generic_tys,
        };

        // And any other mappings I'll need
        self.function_to_id_map.insert(func_key.clone(), func_index);

        return func_index;
    }

    pub(crate) fn define_function(&mut self, function_name: &str) {
        let func_def = self.internal_functions[function_name];

        // Collect any generic info for key
        let gen_tys: Vec<Ty> = func_def
            .generics
            .iter()
            .map(|g| {
                let crate::frontend::ast::Type::Generic {
                    generic_name,
                    index_in_decl: _,
                } = g
                else {
                    panic!()
                };
                self.generic_context.get_mapping(&generic_name.text).clone()
            })
            .collect();

        let fn_key = GenericInstTyKeyRef {
            name: &func_def.name.text,
            tys: &gen_tys,
        };
        //

        let (param_tys, _ret_tys, uses_sret) = self.get_function_params(func_def);

        let function_id = *self
            .function_to_id_map
            .get(&fn_key)
            .expect(&format!("no function for key {:?}", fn_key));
        let function_ctx = FunctionCtx::new(function_name.to_owned(), param_tys, function_id, self);
        self.function_ctx_stack.push(function_ctx);

        // Create a new function-wide variable context
        self.function_ctx_stack
            .current_mut()
            .local_variables
            .push(HashMap::new());

        // Conversion to ty should resolve generics
        let mut def_params: Vec<SemaParam> = func_def
            .params
            .iter()
            .map(|p| SemaParam {
                ty: self.ast_to_ty(&p.ty),
                name: p.name.text.clone(),
                mutable: p.mut_arg,
            })
            .collect();

        if uses_sret {
            let ret_ty_as_ptr = SemaParam {
                mutable: false,
                name: "__sret_gen".to_string(),
                ty: self.ast_to_ty(&func_def.ret_type),
            };
            def_params.insert(0, ret_ty_as_ptr);
        }

        // Def Params MUST match the params defined in the type, otherwise this will break
        // TODO: Maybe keep those in a map to check against
        // Functions should be passed pointers to COPYS of structs / arrays when passed by value, so I should just be able to
        // register the locals - the pointers thould be owned by the called context
        for (idx, param) in def_params.iter().enumerate() {
            // Name the parameter
            self.dbg_name_bld.add_local(
                function_id,
                idx as u32,
                &get_var_dbg_name(&format!("param.{}", param.name), &param.ty),
            );

            // ------------------------------------------------------------------------------------------------------- //
            let needs_stack_loc = if let Some(vec) = self
                .addr_of_uses_by_function
                .get(&self.function_ctx_stack.current().name)
            {
                vec.contains(&param.name)
            } else {
                false
            };
            if !param.ty.is_composite_ty() && needs_stack_loc {
                // Stackalloc space for the type
                let ptr_local = self.stack_alloc(&param.ty, &param.name);

                // Load the position of / pointer to the mem onto the stack
                self.emit_current(Instruction::LocalGet(ptr_local));

                // Load the value of the local onto the stack
                self.emit_current(Instruction::LocalGet(idx as u32));

                // needs position -> value
                // Param ty is ptr for struct & array - need to consider if this will work
                self.emit_store_to_ptr(&param.ty);

                self.function_ctx_stack
                    .current_mut()
                    .local_variables
                    .insert_in_last(
                        param.name.clone(),
                        FunctionVariable::PtrLocal(ptr_local, param.mutable),
                    );
            } else {
                // Struct / arrays pointers will be passed in as locals with pointers inside
                // These are pass by copy pointers
                // Pointers can't point to anything other than memory, so they are PtrLocal
                if param.ty.is_composite_ty() || matches!(param.ty, Ty::Ptr(_)) {
                    self.function_ctx_stack
                        .current_mut()
                        .local_variables
                        .insert_in_last(
                            param.name.clone(),
                            FunctionVariable::PtrLocal(idx as u32, param.mutable),
                        );
                } else {
                    self.function_ctx_stack
                        .current_mut()
                        .local_variables
                        .insert_in_last(
                            param.name.clone(),
                            FunctionVariable::Local(idx as u32, param.mutable),
                        );
                }
            }

            if uses_sret && idx == 0 {
                // sret ptr local is just the local that holds the sret ptr, not the pointer itself
                // Will need to 'get' the local to load the value (the pointer) onto the stack
                self.function_ctx_stack.current_mut().sret_ptr_local = Some(idx as u32);
            }
        }

        // for stmt in &func_def.body {
        //     self.gen_stmt(stmt);
        // }
        // push the return value to the stack or into sret pointer
        let _exprssion_value = self.gen_expr(
            &func_def.body,
            self.function_ctx_stack.current().sret_ptr_local,
        );
        let last_body_instruction = self
            .function_ctx_stack
            .current()
            .current_function
            .last_instruction();

        // If manual return wasn't entered, we need to clean up the stack, since that is tied to return stmt
        if !matches!(last_body_instruction, Some(Instruction::Return)) {
            let stack_ptr_id = self.stack_ptr_id;
            self.function_ctx_stack
                .current_mut()
                .current_function
                .end_stack_frame(stack_ptr_id);
            // Result of the expression should be on the stack (if there is one)
            self.emit_current(Instruction::Return);
        }

        // TODO: Check if return was built - if not, return default value
        // self.emit_current(Instruction::Return);

        // Not really necessary since the whole thing will be popped. But good to pop for every push
        self.function_ctx_stack.current_mut().local_variables.pop();

        // Needs to align up
        let static_data_boundry = self.get_stack_base();
        // Consume the context and encode
        if let Some(fctx) = self.function_ctx_stack.pop() {
            self.code_section_queue.push((
                function_id,
                fctx.current_function
                    .into_encoder(self.stack_ptr_id, static_data_boundry),
            ));
            // self.code_section
            //     .function(&fctx.current_function.into_encoder(self.stack_ptr_id));
        } else {
            panic!("No function context!");
        }
    }

    fn get_function_params(&self, proc_def: &ProcDef) -> (Vec<ValType>, Vec<ValType>, bool) {
        // (param_types, returns, uses_sret)
        let params = proc_def.params.iter().map(|p| &p.ty).collect();
        self.get_wasm_function_sig(&params, &proc_def.ret_type)
    }

    pub fn get_wasm_function_sig(
        &self,
        params: &Vec<&Type>,
        ret: &Type,
    ) -> (Vec<ValType>, Vec<ValType>, bool) {
        let ret_sema = self.ast_to_ty(&ret);
        let uses_sret = ret_sema.is_composite_ty();

        let mut param_types: Vec<ValType> = params
            .iter()
            .map(|t| {
                let sema_param = self.ast_to_ty(&t);
                self.wasm_param_type(&sema_param)
            })
            .collect();

        let mut returns = vec![];

        if uses_sret {
            param_types.insert(0, ValType::I32);
        } else if *ret != Type::Void {
            // If it isn't using sret, then it could have a proper return type
            returns.push(self.wasm_param_type(&ret_sema));
        }

        (param_types, returns, uses_sret)
    }

    // I'm not sure I can guerentee this type exists
    pub fn get_type_index_from_signature(&mut self, args: &Vec<Ty>, ret: &Ty) -> u32 {
        let ret_sema = ret;
        let uses_sret = ret_sema.is_composite_ty();

        let mut param_types: Vec<ValType> = args.iter().map(|t| self.wasm_param_type(&t)).collect();

        let mut returns = vec![];

        if uses_sret {
            param_types.insert(0, ValType::I32);
        } else if *ret != Ty::Void {
            returns.push(self.wasm_param_type(&ret_sema));
        }

        self.get_or_create_function_type(&param_types, &returns)
    }

    /// Returns the function type, given the signature
    ///
    /// Unrelated to the function ID (index)
    pub(crate) fn get_or_create_function_type(
        &mut self,
        params: &Vec<ValType>,
        ret: &Vec<ValType>,
    ) -> u32 {
        let sigref = SigRef { params, ret };
        if let Some(val) = self.sig_to_type_map.get(&sigref) {
            return *val;
        } else {
            let ty_id = self.type_section.len();
            self.sig_to_type_map
                .insert((params.clone(), ret.clone()), ty_id);
            self.type_section.ty().function(params.clone(), ret.clone());
            self.dbg_name_bld
                .add_type(ty_id, &Self::function_type_name(params, ret));
            return ty_id;
        }
    }

    fn function_type_name(params: &Vec<ValType>, ret: &Vec<ValType>) -> String {
        return format!("({:?}) -> ({:?})", params, ret);
    }

    pub fn wasm_param_type(&self, sema_ty: &Ty) -> ValType {
        match sema_ty {
            Ty::I8 | Ty::U8 | Ty::I16 | Ty::U16 | Ty::I32 | Ty::U32 => ValType::I32,
            Ty::I64 | Ty::U64 => ValType::I64,
            Ty::F32 => ValType::F32,
            Ty::F64 => ValType::F64,
            Ty::USize => ValType::I32,
            Ty::Bool => ValType::I32,
            Ty::Ptr(_ty) => ValType::I32,
            Ty::Array(_ty, _) => ValType::I32, // Needs to be converted to a pointer
            Ty::Struct(_, _generics) => ValType::I32, // Needs to be converted to a pointer
            Ty::Union(_, _generics) => ValType::I32, // also needs to be a pointer
            Ty::FuncPtr(_items, _ty) => ValType::I32, // Needs to be an index to the function
            Ty::Void => panic!("Void is not mappable to a wasm val type"),
            Ty::NullPtr(_ty) => ValType::I32,
            Ty::FuncGeneric(generic_name, _) => {
                let mapping = self.generic_context.get_mapping(&generic_name);
                self.wasm_param_type(&mapping)
            }
            Ty::Error => unreachable!(),
        }
    }

    pub fn write_code_section(&mut self) {
        self.code_section_queue.sort_by_key(|(id, _)| *id);
        for (_id, func) in self.code_section_queue.drain(..) {
            self.code_section.function(&func);
        }
        self.module.section(&self.code_section);
    }

    pub fn write_elements_section(&mut self) {
        let function_ids: Vec<u32> = self
            .table_entries_to_write
            .iter()
            .map(|e| e.func_index.clone())
            .collect();
        self.element_section.active(
            Some(0),
            &ConstExpr::i32_const(0),
            Elements::Functions(Cow::Borrowed(&function_ids)),
        );
        self.module.section(&self.element_section);
    }
}

#[derive(Hash, Clone, Copy, PartialEq, Eq)]
struct SigRef<'b> {
    params: &'b Vec<ValType>,
    ret: &'b Vec<ValType>,
}

impl Equivalent<(Vec<ValType>, Vec<ValType>)> for SigRef<'_> {
    fn equivalent(&self, key: &(Vec<ValType>, Vec<ValType>)) -> bool {
        *self.params == key.0 && *self.ret == key.1
    }
}

#[allow(unused)]
pub struct TableEntry {
    pub table_index: u32,
    pub func_index: u32,
    pub type_index: u32,
}
